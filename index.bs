<pre class='metadata'>
Title: ARIA-AT Automation
Shortname: aria-at-automation
Level: 1
Status: w3c/CG-DRAFT
Group: ARIA-AT CG
Repository: w3c/aria-at-automation
URL: https://w3c.github.io/aria-at-automation/
Editor: Simon Pieters, Bocoup https://bocoup.com, simon@bocoup.com
!Tests: <a href=https://github.com/w3c/web-platform-tests/tree/master/aria-at-automation>web-platform-tests aria-at-automation/</a> (<a href=https://github.com/w3c/web-platform-tests/labels/aria-at-automation>ongoing work</a>)
Abstract: A short description of your spec, one or two sentences. (TODO)
</pre>

Introduction {#intro}
=====================

AT Driver defines a protocol for introspection and remote control of assistive technology software, using a bidirectional communication channel.

Explainer {#explainer}
======================

Specify a protocol using WebSocket that maximally reuses concepts and conventions from [WebDriver BiDi](https://w3c.github.io/webdriver-bidi/).

A connection has two endpoints: remote and local. The remote end can control and read from the screen reader, which can either be implemented as a standalone application or be implemented as part of the AT software. The local end is what the test interfaces with, usually in the form of language-specific libraries providing an API.

There should only be the WebSocket form of communication -- as in [BiDi-only sessions for WebDriver BiDi](https://w3c.github.io/webdriver-bidi/#supports-bidi-only-sessions).

A connection can have 0 or more [=sessions=]. Each session corresponds to an instance of an AT. We may limit the maximum number of sessions per AT to 1 initially.

Commands are grouped into modules. The modules could be: Sessions, Settings, Actions.

Message transport is provided using the WebSocket protocol.

The protocol is defined using a Concise Data Definition Language (CDDL) definition. The serialization is JSON.

Example {#explainer-example}
----------------------------

First, the local end would establish a WebSocket connection.

The local end then creates a session by sending

```
{"method":"session.new","params":{...}}
```

The local end can then send commands to change settings or send key press actions for that session. The local end assigns a command id (which is included in the message). The remote end sends a message back with the result and the command id, so the local end knows which command the message applies to.

When the screen reader speaks, the remote end will send a message as to the local end with the spoken text. This could be in the form of an event, which is not tied to any particular command.

Infrastructure {#infra}
=======================

This specification uses the same terms as in WebDriver BiDi, but the remote end is assistive technology software instead of a web browser. Some terms are redefined herein. Contrary to WebDriver, this specification does not use HTTP, only WebSocket.

Issue: need to define this properly.

Interface {#interface}
======================

Issue: https://w3c.github.io/webdriver/#interface exposes to the page JS that webdriver is active. Do we need to expose that atdriver is active?

Nodes {#nodes}
==============

The AT Driver protocol consists of communication between:

: <dfn>local end</dfn>
:: The local end represents the client side of the protocol, which is usually in the form of language-specific libraries providing an API on top of the AT Driver protocol. This specification does not place any restrictions on the details of those libraries above the level of the wire protocol.
: <dfn>remote end</dfn>
:: The remote end hosts the server side of the protocol. The remote end is responsible for driving and listening to the assistive technology and sending information to the local end as defined in this specification.

Protocol {#protocol}
====================

This section defines the basic concepts of the AT Driver protocol. These terms are distinct from their representation at the [=transport=] layer.

The protocol is defined using a CDDL definition. For the convenience of implementors two seperate CDDL definitions are defined; the <dfn>remote end definition</dfn> which defines the format of messages produced on the [=local end=] and consumed on the [=remote end=], and the <dfn>local end definition</dfn> which defines the format of messages produced on the [=remote end=] and consumed on the [=local end=].


Definition {#protocol-definition}
---------------------------------

Issue: https://w3c.github.io/webdriver-bidi/#protocol-definition


Session {#protocol-session}
---------------------------

A <dfn>session</dfn> represents the connection between a [=local end=] and a specific [=remote end=].

Modules {#protocol-modules}
---------------------------

The AT Driver protocol is organized into modules.

Each <dfn>module</dfn> represents a collection of related [=commands=] and [=events=] pertaining to a certain aspect of the assistive technology.

Each module has a <dfn>module name</dfn> which is a string. The [=command name=] and [=event name=] for commands and events adefined in the module start with the [=module name=] followed by a period "`.`".

Modules which contain [=commands=] define [=remote end definition=] fragments.

Commands {#protocol-commands}
-----------------------------

A <dfn>command</dfn> is an asynchronous operation, requested by the [=local end=] and run on the [=remote end=], resulting in either a result or an error being returned to the [=local end=]. Multiple commands can run at the same time, and commands can potentially be long-running. As a consequence, commands can finish out-of-order.

Each [=command=] is defined by:

* A <dfn>command type</dfn> which is defined by a [=remote end definition=] fragment containing a group. Each such group has two fields:
  * `method` which is a string literal in the form `[module name].[method name]`. This is the <dfn>command name</dfn>.
  * `params` which defines a mapping containing data that to be passed into the command. The populated value of this map is the <dfn>command parameters</dfn>.
* A <dfn>result type</dfn>, which is defined by the [=local end definition=] fragment.
* A set of [=remote end steps=] which define the actions to take for a command given a [=session=] and [=command parameters=] and return an instance of the command [=return type=].

A command that cna run without an active session is a <dfn>static command</dfn>. Commands are not static commands unless stated in their definition.

When commands are sent from the [=local end=] they have a command id. This is an identifier used by the [=local end=] to identify the response from a particular command. From the point of view of the [=remote end=] this identifier is opaque and cannot be used internally to identify the command.

Events {#protocol-events}
-------------------------

An <dfn>event</dfn> is a notification, sent by the [=remote end=] to the [=local end=], signaling that something of interest has occurred oin the [=remote end=].

* An <dfn>event type</dfn> is defined by a [=local end definition=] fragment containing a group. Each such group has two fields:
  * `method` which is a string literal of the form `[module name].[event name]`. This is the <dfn>event name</dfn>.
  * `params` which defins a mapping containing event data. The populated value of this map is the <dfn>event parameters</dfn>.
* A <dfn>remote end event trigger</dfn> which defines when the event is triggered and steps to construct the [=event type=] data.

Transport {#transport}
======================

Message transport is provided using the WebSocket protocol. [[!RFC6455]]

Issue: TODO <dfn>start listening for a WebSocket connection</dfn>;
<dfn>handle an incoming message</dfn>;
<dfn>emit an event</dfn>;
<dfn>respond with an error</dfn>
<dfn>handle a connection closing</dfn>

Establinshing a Connection {#transport-establishing}
----------------------------------------------------

The URL to the WebSocket server is communicated out-of-band. When an implementation is ready to accept requests to start an AT Driver session, it must:

1. [=Start listening for a WebSocket connection=] given null.

Common Data Types {#data-types}
===============================

TODO https://w3c.github.io/webdriver-bidi/#data-types

Modules {#modules}
==================

The session Module {#module-session}
------------------------------------

### Definition ### {#module-session-definition}

The [=remote end definition=] and [=local end definition=] are the same as the <a href="https://w3c.github.io/webdriver-bidi/#module-session-definition">WebDriver BiDi session Module's definition</a>.

### Types ### {#module-session-types}

#### The session.CapabilitiesRequest Type #### {#module-session-CapabilitiesRequest}

[=Remote end definition=] and [=local end definition=]:

```
Capabilities = {
  ?atName: text,
  ?atVersion: text,
  ?platformName: text,
  *text => any
};
```

The `CapabilitiesRequest` type represents capabilities requested for a session.

### Commands ###{#module-session-commands}

#### The session.new Command #### {#module-session-new}

The <dfn>session.new</dfn> command allows creating a new [=session=]. This is a [=static command=].

<dl>
  <dt>Command Type
  <dd>The command type definition is the same as the WebDriver BiDi session.new command's definition.
  <dt>Return Type
  <dd>

```
SessionNewResult = {
  sessionId: text,
  capabilities: {
    atName: text,
    atVersion: text,
    platformName: text,
    *text => any
  }
}
```

</dl>

The [=remote end steps=] given |session| and |command parameters| are:

1. ... process capabilities, create a session, generate a session id
2. Let |body| be a new map matching the `SessionNewResult` production, with the `sessionId` field set to |session|â€™s [=session ID=], and the `capabilities` field set to |capabilities|.
3. Return [=success=] with data |body|.

The settings Module {#module-settings}
--------------------------------------

Issue: TODO enunciate capital letters, enunciate punctuation

Privacy {#privacy}
==================

It is advisable that [=remote ends=] create a new profile when creating a new session. This prevents potentially sensitive session data from being accessible to new sessions, ensuring both privacy and preventing state from bleeding through to the next session.

Security {#security}
====================

An assistive technology can rely on a command-line flag or a configuration option to test whether to enable AT Driver, or alternatively make the assistive technology initiate or confirm the connection through a privileged content document or control widget, in case the assistive technology does not directly implement the WebSocket endpoints.

It is strongly suggested that assistive technology require users to take explicit action to enable AT Driver, and that AT Driver remains disabled in publicly consumed versions of the assistive technology.

To prevent arbitrary machines on the network from connecting and creating sessions, it is suggested that only connections from loopback devices are allowed by default.

The remote end can include a configuration option to limit the accepted IP range allowed to connect and make requests. The default setting for this might be to limit connections to the IPv4 localhost CIDR range 127.0.0.0/8 and the IPv6 localhost address ::1. [[RFC4632]]

It is also suggested that assistive technologies make an effort to indicate that a session that is under control of AT Driver. The indication should be accessible also for non-visual users. For example, this can be done through an OS-level notification or alert dialog.

Issue: TODO sandbox (limit availability to information that apps usually can't access, e.g. login screen).

Issue: TODO no HID level simulated keypresses.

Issue: TODO exclude access to any security-sensitive settings.

Issue: TODO exclude access to any security-sensitive commands.
